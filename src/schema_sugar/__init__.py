#!/usr/bin/env python
# coding=utf-8
import json
import click
import jsonschema
from abc import abstractmethod
from jsonschema import Draft4Validator
from schema_sugar.constant import CLI_MAP, HTTP_MAP, SHOW_OP, OPERATIONS


class JsonForm(object):

    schema = {}

    def __init__(self, json_data, strict=False):
        if not hasattr(json_data, '__getitem__'):
            raise TypeError('json_data must be a dict.')
        if not self.schema:
            raise NotImplementedError('schema not implemented!')
        Draft4Validator.check_schema(self.schema)

        self.data = {}
        if not strict:
            self._filter_data(json_data, self.schema['properties'], self.data)
        else:
            self.data = json_data
        self.validator = Draft4Validator(self.schema)
        self.errors = None

    def validate(self):
        try:
            self.validator.validate(self.data, self.schema)
            return True
        except jsonschema.ValidationError as e:
            self.errors = str(e)
            return False

    def _filter_data(self, data, properties, output):
        for key in data:
            if key in properties:
                if properties[key]['type'].lower() == 'object':
                    output[key] = {}
                    self._filter_data(data[key], properties[key]['properties'], output[key])
                elif properties[key]['type'].lower() == 'number':
                    try:
                        output[key] = int(data[key])
                    except (ValueError, TypeError):
                        output[key] = data[key]
                elif properties[key]['type'].lower() == 'string':
                    try:
                        output[key] = str(data[key])
                    except UnicodeEncodeError:
                        output[key] = data[key]
                else:
                    output[key] = data[key]


# more adapter is required for "optional", "default", etc
ARG_CONV_MAP = {
    "number": lambda name: click.argument(name, type=click.INT),
    "string": lambda name: click.argument(name, type=click.STRING)
}

def op2method(method_string):
    """
    Convert http method name or cli operation name to curd name string.
    :param method_string:
    :return: converted method string in
    :rtype basestring
    """
    method_string = method_string.lower()
    if method_string in OPERATIONS:
        return method_string
    elif method_string in CLI_MAP:
        return CLI_MAP[method_string]
    elif method_string in HTTP_MAP:
        return HTTP_MAP[method_string]
    else:
        raise ValueError("method `%s` not in convention map" % method_string)


class SchemaSugarBase(object):
    """
    Generate resource or blue print to web app and CLI app.
    """
    _default_operation = SHOW_OP

    def __init__(self, url=None, config=None):
        if not hasattr(self, "config") and config is not None:
            self.config = config
        if not hasattr(self, "url") and url is not None:
            self.url = url

    @abstractmethod
    def make_resource(self, *args, **kwargs):
        pass

    def make_cli(self, parent_command):
        """
        Register me to the parent_command and return the command function.
        :param parent_command: generated by click.command() function.
        :return: a click command function
        """

        def command_entity(**kwargs):
            if kwargs:
                operation = kwargs.pop("operation")
            else:
                operation = self._default_operation
            return self._api_run(kwargs, operation)

        command = parent_command.command(
            name=self.url.strip("/"), help=self.schema['help']
        )(command_entity)
        command = click.argument(
            "operation",
            type=click.Choice(self.cli_methods)
        )(command)
        for member in self.schema['properties'].items():
            command = ARG_CONV_MAP[member[1]["type"]](member[0])(command)
        return command

    def cli_response(self, result, **kwargs):
        return json.dumps(result)

    @abstractmethod
    def web_response(self, result, **kwargs):
        pass

    @abstractmethod
    def create(self):
        pass

    @abstractmethod
    def show(self, data, web_request, **kwargs):
        return data

    @abstractmethod
    def update(self, data, web_request, **kwargs):
        pass

    @abstractmethod
    def delete(self, data, web_request, **kwargs):
        pass

    def process(self, data, method, web_request, **kwargs):
        return getattr(self, op2method(method))(data, web_request, **kwargs)

    def _api_run(self, data, method, web_request=None, **kwargs):
        data = self._pre_processing(data, web_request, **kwargs)

        result = self.process(data, method, web_request, **kwargs)
        if web_request is not None:
            return self.web_response(result)
        else:
            return self.cli_response(result)

    def _pre_processing(self, data, web_request, **kwargs):
        # validation
        class FormClass(JsonForm):
            schema = self.schema
        form = FormClass(data)
        if not form.validate():
            raise ValueError("%s " % form.errors)
        return form.data

    def get_doc(self, *args, **kwargs):
        return "This is the example doc data:\n" + str(self.schema)

    def dumps(self):
        return self.config

    @property
    def schema(self):
        return self.config['schema']

    @property
    def version(self):
        return self.config.get('version', 0)

    @property
    def cli_methods(self):
        return self.config.get('cli_methods', CLI_MAP.keys())

    @property
    def http_methods(self):
        return self.config.get('http_methods', HTTP_MAP.keys())

    @property
    def url(self):
        return self.config['url']

    @classmethod
    def from_string(cls, config_string):
        """
        Create a new instance from given serialized schema string.
        :param config_string:
        """
        pass


class SugarJarBase(object):

    def __init__(self, name):
        self.name = name

    @abstractmethod
    def run(self):
        pass

    @staticmethod
    @click.group()
    def entry_point():
        pass

    @abstractmethod
    def register(self, schema_sugar):
        pass


@click.command(help="To implement")
@click.argument("code_type", type=click.Choice(['flask', ]))
@click.argument("-out", default="out.py", type=click.STRING)
def code_gen(code_type, out):
    pass
