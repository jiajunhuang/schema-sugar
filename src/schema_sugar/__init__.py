#!/usr/bin/env python
# coding=utf-8
import json
import click
import jsonschema
from abc import abstractmethod
from jsonschema import Draft4Validator
from schema_sugar.constant import CLI_MAP, HTTP_MAP, SHOW_OP, OPERATIONS, CREATE_OP, UPDATE_OP

__version__ = "0.0.1"


class JsonForm(object):

    schema = {}

    def __init__(self, json_data, strict=False, live_schema=None):
        if not hasattr(json_data, '__getitem__'):
            raise TypeError('json_data must be a dict.')
        if (not self.schema) and (live_schema is None):
            raise NotImplementedError('schema not implemented!')
        if live_schema is not None:
            if not self.schema:
                self.schema = live_schema
            else:
                self.live_schema = live_schema
                self.schema['properties'].update(live_schema['properties'])
                if "required" in self.schema and "required" in live_schema:
                    self.schema['required'] = list(set(self.schema['required']) | set(live_schema["required"]))

        Draft4Validator.check_schema(self.schema)

        self.data = {}
        if not strict:
            self._filter_data(json_data, self.schema['properties'], self.data)
        else:
            self.data = json_data
        self.validator = Draft4Validator(self.schema)
        self.errors = None

    def validate(self):
        try:
            self.validator.validate(self.data, self.schema)
            return True
        except jsonschema.ValidationError as e:
            self.errors = str(e)
            return False

    def _filter_data(self, data, properties, output):
        for key in data:
            if key in properties:
                if properties[key]['type'].lower() == 'object':
                    output[key] = {}
                    self._filter_data(data[key], properties[key]['properties'], output[key])
                elif properties[key]['type'].lower() == 'number':
                    try:
                        output[key] = int(data[key])
                    except (ValueError, TypeError):
                        output[key] = data[key]
                elif properties[key]['type'].lower() == 'string':
                    try:
                        output[key] = str(data[key])
                    except UnicodeEncodeError:
                        output[key] = data[key]
                else:
                    output[key] = data[key]


# more adapter is required for "optional", "default", etc

ARG_CONV_MAP = {
    "number": lambda name: click.argument(name, type=click.INT),
    "string": lambda name: click.argument(name, type=click.STRING),
    "boolean": lambda name: click.option("--" + name, is_flag=True, default=True),
    "default": lambda name: click.argument(name, type=click.STRING),
}

def cli_arg_generator(arg_type):
    """
    Return click argument generator function
    :param arg_type: argument type such as `string` , `number`, etc
    :type arg_type: basestring
    :rtype callable
    """
    return ARG_CONV_MAP.get(arg_type, ARG_CONV_MAP['default'])

def op2method(method_string):
    """
    Convert http method name or cli operation name to curd name string.
    :param method_string:
    :return: converted method string in
    :rtype basestring
    """
    method_string = method_string.lower()
    if method_string in OPERATIONS:
        return method_string
    elif method_string in CLI_MAP:
        return CLI_MAP[method_string]
    elif method_string in HTTP_MAP:
        return HTTP_MAP[method_string]
    else:
        raise ValueError("method `%s` not in convention map" % method_string)


class SchemaSugarBase(object):
    """
    Generate resource or blue print to web app and CLI app.
    """
    _default_operation = SHOW_OP

    def __init__(self, config=None):
        if not hasattr(self, "config") and config is not None:
            # TODO(winkidney): config validation
            self.config = config
        elif hasattr(self, "config"):
            pass
        else:
            raise ValueError("config can not be None, expect dict, got %s" % config)

    @abstractmethod
    def make_resource(self, *args, **kwargs):
        pass

    def make_cli(self, parent_command):
        """
        Note: refine is needed because click does not support sub command
         in nested way.
        Register me to the parent_command and return the command function.
        :param parent_command: generated by click.command() function.
        :return: a click command function
        """
        # TODO(winkidney): to improve
        def make_command_entity(passed_operation):
            def command_entity(**kwargs):
                return self._api_run(kwargs, passed_operation)
            return command_entity
        command_list = []
        for support_operation in self.support_operations:
            command = parent_command.command(
                name=self.url.split("/")[1] + "_" + support_operation
            )(make_command_entity(support_operation))
            operation = self.schema.get(support_operation, None)
            if operation is not None:
                for parameter in operation['properties'].items():
                    command = cli_arg_generator(parameter[1]["type"])(parameter[0])(command)
            command_list.append(command)
        return command_list

    def cli_response(self, result, **kwargs):
        click.echo(result)
        return result

    @abstractmethod
    def web_response(self, result, **kwargs):
        pass

    @abstractmethod
    def create(self, data, web_request, **kwargs):
        pass

    @abstractmethod
    def show(self, data, web_request, **kwargs):
        return data

    @abstractmethod
    def update(self, data, web_request, **kwargs):
        pass

    @abstractmethod
    def delete(self, data, web_request, **kwargs):
        pass

    def process(self, data, raw_method, web_request, **kwargs):
        method = op2method(raw_method)
        validate_schema = self.schema.get(method, {"type": "object", "properties": {}})
        processed_data = self.validate(validate_schema, data)
        return getattr(self, method)(processed_data, web_request, **kwargs)

    def _api_run(self, data, method, web_request=None, **kwargs):
        data = self.pre_process(data, web_request, **kwargs)
        result = self.process(data, method, web_request, **kwargs)
        if web_request is not None:
            if isinstance(result, (tuple, list)):
                return self.web_response(result[0], result[1])
            else:
                return self.web_response(result)
        else:
            return self.cli_response(result)

    @staticmethod
    def validate(validate_schema, data):
        schema = validate_schema
        form = JsonForm(data, live_schema=schema)
        if not form.validate():
            raise ValueError("%s " % form.errors)
        return form.data

    def pre_process(self, data, web_request, **kwargs):
        return data

    def get_doc(self, *args, **kwargs):
        return "This is the example doc data:\n" + str(self.schema)

    def dumps(self):
        return self.config

    @property
    def schema(self):
        return self.config['schema']

    @property
    def version(self):
        return self.config.get('version', 0)

    @property
    def support_operations(self):
        return self.schema['support_operations']

    @property
    def cli_methods(self):
        return self.config.get('cli_methods', CLI_MAP.keys())

    @property
    def http_methods(self):
        return self.config.get('http_methods', HTTP_MAP.keys())

    @property
    def url(self):
        return self.config['url']

    @classmethod
    def from_string(cls, config_string):
        """
        Create a new instance from given serialized schema string.
        :param config_string:
        """
        pass


class SugarJarBase(object):

    def __init__(self, name):
        self.name = name

    @abstractmethod
    def run(self):
        pass

    @staticmethod
    @click.group(name="SugarJarEntry")
    def entry_point():
        pass

    @abstractmethod
    def register(self, schema_sugar):
        pass


@click.command(help="To implement")
@click.argument("code_type", type=click.Choice(['flask', ]))
@click.argument("-out", default="out.py", type=click.STRING)
def code_gen(code_type, out):
    pass
